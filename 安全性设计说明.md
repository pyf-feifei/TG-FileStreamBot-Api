# HTTP文件上传API安全性设计

## 1. 文件安全检查

### 1.1 文件类型验证
```go
// 配置文件：fsb.env
ALLOWED_MIME_TYPES=image/jpeg,image/png,video/mp4,application/pdf
ALLOWED_EXTENSIONS=.jpg,.jpeg,.png,.mp4,.pdf

// 实现代码
func validateFileType(file *multipart.FileHeader) error {
    // 1. MIME类型检查
    mimeType := file.Header.Get("Content-Type")
    if !contains(ALLOWED_MIME_TYPES, mimeType) {
        return fmt.Errorf("不允许的文件类型: %s", mimeType)
    }

    // 2. 文件扩展名检查
    ext := strings.ToLower(filepath.Ext(file.Filename))
    if !contains(ALLOWED_EXTENSIONS, ext) {
        return fmt.Errorf("不允许的文件扩展名: %s", ext)
    }

    // 3. 魔数验证（文件内容真实性检查）
    if err := validateFileSignature(file); err != nil {
        return err
    }

    return nil
}

// 魔数验证 - 检查文件头真实性
func validateFileSignature(file multipart.File) error {
    header := make([]byte, 512)
    file.Read(header)
    file.Seek(0, 0) // 重置文件指针

    // 检查常见文件头
    if bytes.HasPrefix(header, []byte{0xFF, 0xD8, 0xFF}) {
        // JPEG
        return nil
    } else if bytes.HasPrefix(header, []byte{0x89, 0x50, 0x4E, 0x47}) {
        // PNG
        return nil
    } else if bytes.HasPrefix(header, []byte{0x25, 0x50, 0x44, 0x46}) {
        // PDF
        return nil
    } else if bytes.HasPrefix(header, []byte{0x00, 0x00, 0x00, 0x18}) {
        // MP4
        return nil
    }

    return fmt.Errorf("文件类型与扩展名不匹配")
}
```

### 1.2 文件名安全处理
```go
func sanitizeFilename(filename string) string {
    // 1. 移除路径分隔符
    filename = strings.ReplaceAll(filename, "..", "")
    filename = strings.ReplaceAll(filename, "/", "_")
    filename = strings.ReplaceAll(filename, "\\", "_")

    // 2. 移除特殊字符
    reg := regexp.MustCompile(`[<>:"/\\|?*]`)
    filename = reg.ReplaceAllString(filename, "_")

    // 3. 限制长度
    if len(filename) > 255 {
        filename = filename[:255]
    }

    // 4. 添加随机前缀防止重名冲突
    random := utils.GetShortHash(time.Now().String())[:8]
    return fmt.Sprintf("%s_%s", random, filename)
}
```

### 1.3 用户认证
```go
// 配置：UPLOAD_TOKENS=token1,token2,token3
var uploadTokens = strings.Split(config.ValueOf.UploadTokens, ",")

func authenticateUpload(ctx *gin.Context) bool {
    token := ctx.GetHeader("Authorization")
    if token == "" {
        return false
    }

    // 移除"Bearer "前缀
    token = strings.TrimPrefix(token, "Bearer ")

    // 检查token是否在白名单中
    for _, validToken := range uploadTokens {
        if token == validToken {
            return true
        }
    }

    return false
}
```

## 2. 速率控制实现

### 2.1 基于用户的速率限制
```go
type RateLimiter struct {
    userUploads map[string][]time.Time // 每个用户的上传时间记录
    mutex       sync.RWMutex
    maxPerMinute int
    maxPerHour   int
}

func (rl *RateLimiter) CheckLimit(userID string) (bool, time.Duration) {
    rl.mutex.Lock()
    defer rl.mutex.Unlock()

    now := time.Now()

    // 清理过期记录
    rl.cleanupOldUploads(now)

    uploads := rl.userUploads[userID]

    // 检查每分钟限制
    recentCount := 0
    for _, uploadTime := range uploads {
        if now.Sub(uploadTime) < time.Minute {
            recentCount++
        }
    }

    if recentCount >= rl.maxPerMinute {
        waitTime := time.Minute - now.Sub(uploads[len(uploads)-1])
        return false, waitTime
    }

    // 检查每小时限制
    hourAgo := now.Add(-time.Hour)
    hourCount := 0
    for _, uploadTime := range uploads {
        if uploadTime.After(hourAgo) {
            hourCount++
        }
    }

    if hourCount >= rl.maxPerHour {
        waitTime := time.Hour - now.Sub(uploads[0])
        return false, waitTime
    }

    // 记录此次上传
    rl.userUploads[userID] = append(uploads, now)
    return true, 0
}
```

### 2.2 基于文件大小的限制
```go
func checkFileSize(file *multipart.FileHeader) error {
    // 1. 单个文件大小限制
    if file.Size > config.ValueOf.MaxFileSize {
        return fmt.Errorf("文件超过最大限制 %d MB", config.ValueOf.MaxFileSize/(1024*1024))
    }

    // 2. 用户总存储限制（防止恶意填满频道）
    userQuotaUsed, err := getUserCurrentStorageUsage(userID)
    if err != nil {
        return err
    }

    if userQuotaUsed+file.Size > config.ValueOf.UserQuota {
        return fmt.Errorf("超出存储配额 %d MB", config.ValueOf.UserQuota/(1024*1024))
    }

    return nil
}

func getUserCurrentStorageUsage(userID string) (int64, error) {
    // 查询用户在LOG_CHANNEL中已上传的文件总大小
    messages, err := getMessagesFromChannel(config.ValueOf.LogChannelID, userID)
    if err != nil {
        return 0, err
    }

    var totalSize int64
    for _, msg := range messages {
        if doc, ok := msg.Media.(*tg.MessageMediaDocument); ok {
            totalSize += doc.Document.(*tg.Document).Size
        }
    }

    return totalSize, nil
}
```

### 2.3 Telegram API速率管理
```go
type TelegramAPIManager struct {
    workers     []*gotgproto.Client
    currentIndex int
    mutex       sync.Mutex
    lastUse     map[int]time.Time // 每个worker的最后使用时间
    cooldown    time.Duration // API调用冷却时间
}

func (tam *TelegramAPIManager) GetNextAvailableWorker() *gotgproto.Client {
    tam.mutex.Lock()
    defer tam.mutex.Unlock()

    // 轮询查找可用的worker
    for i := 0; i < len(tam.workers); i++ {
        workerIndex := (tam.currentIndex + i) % len(tam.workers)
        worker := tam.workers[workerIndex]

        // 检查worker是否在冷却期
        if lastUse, exists := tam.lastUse[workerIndex]; !exists ||
           time.Since(lastUse) > tam.cooldown {
            tam.currentIndex = workerIndex
            tam.lastUse[workerIndex] = time.Now()
            return worker
        }
    }

    // 所有worker都在冷却，返回第一个并记录警告
    worker := tam.workers[tam.currentIndex]
    tam.currentIndex = (tam.currentIndex + 1) % len(tam.workers)

    utils.Logger.Warn("All workers are on cooldown, using worker with minimal wait")
    return worker
}
```

## 3. 监控和报警

### 3.1 实时监控指标
```go
type UploadMetrics struct {
    TotalUploads      int64     // 总上传次数
    TotalSize         int64     // 总上传大小
    FailedUploads     int64     // 失败上传次数
    BlockedUploads     int64     // 被阻止的上传次数
    ActiveUsers       int        // 当前活跃用户数
    AverageUploadSize  float64   // 平均文件大小
}

func (um *UploadMetrics) UpdateMetrics(fileSize int64, success bool, userID string) {
    atomic.AddInt64(&um.TotalUploads, 1)
    atomic.AddInt64(&um.TotalSize, fileSize)

    if !success {
        atomic.AddInt64(&um.FailedUploads, 1)
    }

    // 定期检查异常
    if um.TotalUploads%100 == 0 {
        um.checkAnomalies()
    }
}

func (um *UploadMetrics) checkAnomalies() {
    // 检查异常模式
    avgSize := float64(um.TotalSize) / float64(um.TotalUploads)

    if avgSize > 100*1024*1024 { // 平均文件>100MB
        utils.Logger.Warn("检测到异常大文件上传模式",
            zap.Float64("avgSizeMB", avgSize/(1024*1024)))
    }

    if um.FailedUploads > um.TotalUploads/10 { // 失败率>10%
        utils.Logger.Error("上传失败率过高",
            zap.Float64("failureRate", float64(um.FailedUploads)/float64(um.TotalUploads)))
    }
}
```

### 3.2 自动保护机制
```go
// 检测到攻击时自动启用保护模式
func enableProtectionMode(reason string) {
    utils.Logger.Error("启用保护模式", zap.String("reason", reason))

    // 1. 提高限制
    config.ValueOf.MaxFileSize = 10 * 1024 * 1024 // 降低到10MB
    rateLimiter.maxPerMinute = 1                   // 每分钟只能上传1个

    // 2. 启用更严格的验证
    config.ValueOf.EnableDeepScan = true

    // 3. 发送管理员通知
    notifyAdmins("保护模式已启用: " + reason)

    // 4. 5分钟后自动恢复
    time.AfterFunc(5*time.Minute, func() {
        disableProtectionMode()
    })
}

func disableProtectionMode() {
    utils.Logger.Info("恢复保护模式")
    config.ValueOf.MaxFileSize = 2 * 1024 * 1024 * 1024 // 恢复2GB
    rateLimiter.maxPerMinute = 5                       // 恢复每分钟5个
    config.ValueOf.EnableDeepScan = false
}
```

## 4. 配置建议

```bash
# 安全配置
ALLOWED_MIME_TYPES=image/jpeg,image/png,image/gif,video/mp4,video/avi,application/pdf,text/plain
ALLOWED_EXTENSIONS=.jpg,.jpeg,.png,.gif,.mp4,.avi,.pdf,.txt
MAX_FILE_SIZE=2147483648        # 2GB
USER_QUOTA=10737418240           # 每用户10GB配额
UPLOAD_TOKENS=token1,token2,token3  # API访问令牌

# 速率限制
UPLOADS_PER_MINUTE=5             # 每用户每分钟最多5个
UPLOADS_PER_HOUR=50              # 每用户每小时最多50个
API_COOLDOWN_SECONDS=1           # API调用间隔1秒
CONCURRENT_UPLOADS_PER_USER=3     # 每用户同时上传数限制

# 保护模式配置
ENABLE_PROTECTION_MODE=true        # 启用自动保护
ANOMALY_THRESHOLD_DEVIATION=2.0  # 异常检测阈值
PROTECTION_AUTO_RECOVERY=true      # 自动恢复保护模式
```

## 5. 实施建议

1. **渐进式部署**: 先在测试环境验证所有安全机制
2. **监控完善**: 部署后密切监控异常行为
3. **定期审计**: 定期检查上传日志和用户行为
4. **快速响应**: 建立攻击响应流程和应急预案
5. **用户教育**: 提供清晰的使用文档和限制说明

这些措施可以有效防止恶意上传、资源滥用和服务中断，同时保证正常用户的体验。